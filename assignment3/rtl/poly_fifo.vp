/*
   A FIFO designed to store all the bbox values. 
 */

/* ***************************************************************************
 * Date           Author  
 * 3/4/2017   Anthony Van  
 *                          
 * ***************************************************************************/

/******************************************************************************
 * PARAMETERIZATION
 * ***************************************************************************/
//; # module parameters
//; my $fifo_size = 4;
//; my $size_bits = 2;
// my $fifo_size       = parameter(Name='FifoSize',
//                                 Val=>4, Min=>2, Step=>1, 
//                                 Doc=>"Number of entries in FIFO. Must be multiple of 2.");
// my $size_bits       = parameter(Name='FifoSize',
//                                 Val=>2, Min=>1, Step=>1, 
//                                 Doc=>"Must be exactly Log2 of fifo size");
//; my $sig_fig    = parameter(Name=>'SigFig',
//;                            Val=>24, Min=>1, Step=>1, 
//;                            Doc=>"Bits in color and position.");
//; my $verts      = parameter(Name=>'Vertices',
//;                            Val=>3, Min=>3, Step=>1, 
//;                            Doc=>"Maximum Vertices in micropolygon");
//; my $axis       = parameter(Name=>'Axis',
//;                            Val=>3, Min=>1, Step=>1, 
//;                            Doc=>"Number of axis foreach vertex 3 is (x,y,z).");
//; my $colors     = parameter(Name=>'Colors',
//;                            Val=>3, Min=>1, Step=>1, 
//;                            Doc=>"Number of color channels");

module `mname` (
		input logic  clk, rst, read, write, 
		output logic full, empty,

		input logic signed [`$sig_fig`-1:0] poly_in[`$verts`-1:0][`$axis`-1:0],
  	    input logic unsigned [`$sig_fig`-1:0] color_in[`$colors`-1:0], 
   	    input logic isQuad_in, 
        input logic signed [`$sig_fig`-1:0] box_in[1:0][1:0],

		output logic signed [`$sig_fig`-1:0] poly_out[`$verts`-1:0][`$axis`-1:0], 
  	    output logic unsigned [`$sig_fig`-1:0] color_out[`$colors`-1:0] , 
   	    output logic isQuad_out, 
        output logic signed [`$sig_fig`-1:0] box_out[1:0][1:0],
    output logic valid
   );
   logic empty;
   
   logic signed [`$sig_fig`-1:0] poly_array[`$fifo_size`-1:0][`$verts`-1:0][`$axis`-1:0];
   logic unsigned [`$sig_fig`-1:0] color_array [`$fifo_size`-1:0][`$colors`-1:0] ;
   logic isQuad_array[`$fifo_size`-1:0]; 
   logic signed [`$sig_fig`-1:0] box_array[`$fifo_size`-1:0][1:0][1:0];
   
   logic unsigned [`$size_bits`-1:0] nRead, nextRead, nWrite, nextWrite;
   logic enWrite, enRead;
   
   always_comb begin
      empty = (nRead == nWrite);
      full = (nRead == nextWrite);

      nextRead = nRead + 1;
      nextWrite = nWrite + 1;
      enWrite = (!full && write);
      enRead = (!empty && read);
   end
   
   /* Manage queue parameters after reads/writes */

   //; my $d_nrd = generate( 'dff', "d_nrd", 
   //;                        BitWidth=>$size_bits,
   //;                        PipelineDepth=>1,
   //;                        Retime=>'NO' );
   `$d_nrd->instantiate()`(
			      .in(nextRead) , 
			      .clk(clk) , .reset(rst), .en(enRead),
			      .out(nRead));
   
   //; my $d_nwr = generate( 'dff', "d_nwr", 
   //;                        BitWidth=>$size_bits,
   //;                        PipelineDepth=>1,
   //;                        Retime=>'NO' );
   `$d_nwr->instantiate()`(
			      .in(nextWrite) , 
			      .clk(clk) , .reset(rst), .en(enWrite),
			      .out(nWrite));
   
   /* Write in the values into the array upon write request */
   
   always_ff @(posedge clk) begin
      poly_array[nWrite] <= enWrite ? poly_in
        : poly_array[nWrite];
      color_array[nWrite] <= enWrite ? color_in
        : color_array[nWrite];
      box_array[nWrite] <= enWrite ? box_in
        : box_array[nWrite];
      isQuad_array[nWrite] <= enWrite ? isQuad_in
        : isQuad_array[nWrite];
      
      valid <= enRead; 
   end
   
   
/* Read in array values */

   //; my $d_bbx_f1r = generate( 'dff3', "d_bbx_f1r", 
   //;                        BitWidth=>$sig_fig,
   //;                        ArraySize1=>$verts,
   //;                        ArraySize2=>$axis,
   //;                        PipelineDepth=>1,
   //;                        Retime=>'NO' );
   `$d_bbx_f1r->instantiate()` (
			       .out(poly_out) , 
			       .clk(clk) , .reset(rst), .en(enRead),
			       .in(poly_array[nRead]));
   
   //; my $d_bbx_f2r = generate( 'dff2', "d_bbx_f2r", 
   //;                        BitWidth=>$sig_fig,
   //;                        ArraySize1=>$colors,
   //;                        PipelineDepth=>1,
   //;                        Retime=>'NO' );
   `$d_bbx_f2r->instantiate()`(
			      .out(color_out) , 
			      .clk(clk) , .reset(rst), .en(enRead),
			      .in(color_array[nRead]));
   
   //; my $d_bbx_f3r = generate( 'dff3', "d_bbx_f3r", 
   //;                        BitWidth=>$sig_fig,
   //;                        ArraySize1=>2,
   //;                        ArraySize2=>2,
   //;                        PipelineDepth=>1,
   //;                        Retime=>'NO' );
   `$d_bbx_f3r->instantiate()` (
			       .out(box_out) , 
			       .clk(clk) , .reset(rst), .en(enRead),
			       .in(box_array[nRead]));
   
   //; my $d_bbx_f4r = generate( 'dff', "d_bbx_f4r", 
   //;                        BitWidth=>1,
   //;                        PipelineDepth=>1,
   //;                        Retime=>'NO' );
   `$d_bbx_f4r->instantiate()`(
			      .out(isQuad_out) , 
			      .clk(clk) , .reset(rst), .en(enRead),
			      .in(isQuad_array[nRead]));
			      
			      
	 /* Error checking */
   property rb_lt( rst, a , b , c );
      @(posedge clk) rst | ((a<=b) | !c);
   endproperty

   assert property( rb_lt( rst, box_in[0][0] , box_in[1][0] , enWrite));
   assert property( rb_lt( rst, box_in[0][1] , box_in[1][1] , enWrite));
   
   assert property( rb_lt( rst, box_array[nRead][0][0] , box_array[nRead][1][0] , enRead));
   assert property( rb_lt( rst, box_array[nRead][0][1] , box_array[nRead][1][1] , enRead));

endmodule 
