/*
   A FIFO designed to store all the bbox values. 
 */

/* ***************************************************************************
 * Date           Author  
 * 3/4/2017   Anthony Van  
 *                          
 * ***************************************************************************/

/******************************************************************************
 * PARAMETERIZATION
 * ***************************************************************************/
//; # module parameters
//; my $fifo_size = 4;
//; my $size_bits = 2;
//; my $sig_fig    = parameter(Name=>'SigFig',
//;                            Val=>24, Min=>1, Step=>1, 
//;                            Doc=>"Bits in color and position.");
//; my $verts      = parameter(Name=>'Vertices',
//;                            Val=>3, Min=>3, Step=>1, 
//;                            Doc=>"Maximum Vertices in micropolygon");
//; my $axis       = parameter(Name=>'Axis',
//;                            Val=>3, Min=>1, Step=>1, 
//;                            Doc=>"Number of axis foreach vertex 3 is (x,y,z).");
//; my $colors     = parameter(Name=>'Colors',
//;                            Val=>3, Min=>1, Step=>1, 
//;                            Doc=>"Number of color channels");

module `mname` (
		input logic  clk, rst, read, write, 
		output logic full, empty,

		input logic signed [`$sig_fig`-1:0] poly_in[`$verts`-1:0][`$axis`-1:0],
  	    input logic unsigned [`$sig_fig`-1:0] color_in[`$colors`-1:0], 
   	    input logic isQuad_in, 
        input logic signed [`$sig_fig`-1:0] box_in[1:0][1:0],

		output logic signed [`$sig_fig`-1:0] poly_out[`$verts`-1:0][`$axis`-1:0], 
  	    output logic unsigned [`$sig_fig`-1:0] color_out[`$colors`-1:0] , 
   	    output logic isQuad_out, 
        output logic signed [`$sig_fig`-1:0] box_out[1:0][1:0],
    output logic valid
   );
   logic empty;
   
   logic signed [`$sig_fig`-1:0] poly_array[`$fifo_size`-1:0][`$verts`-1:0][`$axis`-1:0];
   logic unsigned [`$sig_fig`-1:0] color_array [`$fifo_size`-1:0][`$colors`-1:0] ;
   //logic isQuad_array[`$fifo_size`-1:0]; 
   logic signed [`$sig_fig`-1:0] box_array[`$fifo_size`-1:0][1:0][1:0];
   
   logic unsigned [`$size_bits`-1:0] nRead, nextRead, nWrite, nextWrite;
   logic enWrite, enRead;
   logic alreadyRead; 
 
   always_comb begin
      nextRead = nRead + 1;
      nextWrite = nWrite + 1;
      
      empty = (nRead == nWrite);
      full = (nRead == nextWrite);
      
      enWrite = (!full && write);
      enRead = (!empty && read) && ~alreadyRead;
      
      poly_out = poly_array[nRead];
      color_out = color_array[nRead];
      isQuad_out = 1'b0;
      box_out = box_array[nRead];
      valid = !rst & !empty;
   end
   
   /* Manage queue parameters after reads/writes */

   //; my $d_nrd = generate( 'dff', "d_nrd", 
   //;                        BitWidth=>$size_bits,
   //;                        PipelineDepth=>1,
   //;                        Retime=>'NO' );
   `$d_nrd->instantiate()`(
			      .in(nextRead) , 
			      .clk(clk) , .reset(rst), .en(enRead),
			      .out(nRead));
   
   //; my $d_nwr = generate( 'dff', "d_nwr", 
   //;                        BitWidth=>$size_bits,
   //;                        PipelineDepth=>1,
   //;                        Retime=>'NO' );
   `$d_nwr->instantiate()`(
			      .in(nextWrite) , 
			      .clk(clk) , .reset(rst), .en(enWrite),
			      .out(nWrite));
   
   /* Write in the values into the array upon write request */
   
   always_ff @(posedge clk) begin
      poly_array[nWrite] <= enWrite ? poly_in
        : poly_array[nWrite];
      color_array[nWrite] <= enWrite ? color_in
        : color_array[nWrite];
      box_array[nWrite] <= enWrite ? box_in
        : box_array[nWrite];
      alreadyRead <= empty ? 'b0 : read;
      /*isQuad_array[nWrite] <= enWrite ? isQuad_in
        : isQuad_array[nWrite];*/
   end
   
   
			      
	 /* Error checking */
   property rb_lt( rst, a , b , c );
      @(posedge clk) rst | ((a<=b) | !c);
   endproperty

  property not_equal( rst, a , b );
      @(posedge clk) rst | (a != b);
   endproperty
   
   //assert property( not_equal(rst, valid, enRead));

   assert property( rb_lt( rst, box_in[0][0] , box_in[1][0] , enWrite));
   assert property( rb_lt( rst, box_in[0][1] , box_in[1][1] , enWrite));
   
   assert property( rb_lt( rst, box_array[nRead][0][0] , box_array[nRead][1][0] , enRead));
   assert property( rb_lt( rst, box_array[nRead][0][1] , box_array[nRead][1][1] , enRead));

endmodule 
