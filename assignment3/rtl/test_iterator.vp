/*
 *  Bounding Box Sample Test Iteration
 * 
 *  Inputs:
 *    BBox and MicroPolygon Information
 * 
 *  Outputs:
 *    Subsample location and Micropolygon Information
 * 
 *  Function:
 *    Iterate from left to right bottom to top
 *    across the bounding box.
 * 
 *    While iterating set the halt signal in
 *    order to hold the bounding box pipeline in
 *    place.  
 * 
 *    
 * Long Description:
 *    The iterator starts in the waiting state,
 *    when a valid micropolygon bounding box
 *    appears at the input. It will enter the
 *    testing state the next cycle with a 
 *    sample equivelant to the lower left 
 *    cooridinate of the bounding box.
 * 
 *    While in the testing state, the next sample
 *    for each cycle should be one sample interval 
 *    to the right, except when the current sample
 *    is at the right edge.  If the current sample
 *    is at the right edge, the next sample should
 *    be one row up.  Additionally, if the current
 *    sample is on the top row and the right edge,
 *    next cycles sample should be invalid and 
 *    equivelant to the lower left vertice and
 *    next cycles state should be waiting.
 * 
 * 
 *   Author: John Brunhaver
 *   Created:      Thu 07/23/09
 *   Last Updated: Tue 10/01/10
 *
 *   Copyright 2009 <jbrunhaver@gmail.com>   
 *  
 */

/* ***************************************************************************
 * Change bar:
 * -----------
 * Date           Author    Description
 * Sep 19, 2012   jingpu    ported from John's original code to Genesis
 *                          
 * ***************************************************************************/

/******************************************************************************
 * PARAMETERIZATION
 * ***************************************************************************/
//; # module parameters
//; my $sig_fig    = parameter(Name=>'SigFig',
//;                            Val=>24, Min=>1, Step=>1, 
//;                            Doc=>"Bits in color and position.");
//; my $radix      = parameter(Name=>'Radix',
//;                            Val=>10, Min=>1, Step=>1, 
//;                            Doc=>"Fraction bits in color and position");
//; my $verts      = parameter(Name=>'Vertices',
//;                            Val=>3, Min=>3, Step=>1, 
//;                            Doc=>"Maximum Vertices in micropolygon");
//; my $axis       = parameter(Name=>'Axis',
//;                            Val=>3, Min=>1, Step=>1, 
//;                            Doc=>"Number of axis foreach vertex 3 is (x,y,z).");
//; my $colors     = parameter(Name=>'Colors',
//;                            Val=>3, Min=>1, Step=>1, 
//;                            Doc=>"Number of color channels");
//; my $pipe_depth = parameter(Name=>'PipelineDepth',
//;                            Val=>1, Min=>1, Max=>1, Step=>1, 
//;                            Doc=>"How many pipe stages are in this block");
//; my $mod_FSM = parameter(Name=>'ModifiedFSM',
//;                            Val=>'NO', List=>['YES', 'NO'],
//;                            Doc=>"Use Modified FSM to eliminate a wait state");
//;
//; # Convert a Fixed Point Number to a Floating
//; sub unFix {
//;   my $signal_name = shift @_;
//;   my $radix = shift @_;
//;   return " 1.0 * $signal_name / ( 128\'d1 << $radix ) ";
//; }

/* A Note on Signal Names:
 *
 * Most signals have a suffix of the form _RxxN 
 * where R indicates that it is a Raster Block signal
 * xx indicates the clock slice that it belongs to
 * and N indicates the type of signal that it is.
 * H indicates logic high, L indicates logic low,
 * U indicates unsigned fixed point, and S indicates
 * signed fixed point.
 * 
 * For all the signed fixed point signals (logic signed [`$sig_fig`-1:0]),
 * their highest `$sig_fig-$radix` bits, namely [`$sig_fig-1`:`$radix`]
 * represent the integer part of the fixed point number, 
 * while the lowest `$radix` bits, namely [`$radix-1`:0]
 * represent the fractional part of the fixed point number.
 * 
 * 
 * 
 * For signal subSample_RnnnnU (logic [3:0])
 * 1000 for  1x MSAA eq to 1 sample per pixel
 * 0100 for  4x MSAA eq to 4 samples per pixel, 
 *              a sample is half a pixel on a side
 * 0010 for 16x MSAA eq to 16 sample per pixel,
 *              a sample is a quarter pixel on a side.  
 * 0001 for 64x MSAA eq to 64 samples per pixel, 
 *              a sample is an eighth of a pixel on a side.
 * 
 */


module `mname()`
  (
   //Input Signals
   input logic signed [`$sig_fig`-1:0] 	poly_R13S[`$verts`-1:0][`$axis`-1:0], //Micropolygon to Iterate Over
   input logic unsigned [`$sig_fig`-1:0] color_R13U[`$colors`-1:0] , //Color of Poly
   input logic 				isQuad_R13H, //Micropolygon is quad
   input logic signed [`$sig_fig`-1:0] 	box_R13S[1:0][1:0], //Box to iterate for subsamples
   input logic 				validPoly_R13H, //Micropolygon is valid

   //Control Signals
   input logic [3:0] 			subSample_RnnnnU , //Subsample width 
   output logic 			halt_RnnnnL , //Halt -> hold current micropoly
   //Note that this block generates
   //Global Signals
   input logic 				clk, // Clock
   input logic 				rst, // Reset

   //Outputs
   output logic signed [`$sig_fig`-1:0] poly_R14S[`$verts`-1:0][`$axis`-1:0], //Micropolygon to Sample Test
   output logic unsigned [`$sig_fig`-1:0] color_R14U[`$colors`-1:0] , //Color of Poly
   output logic signed [`$sig_fig`-1:0] sample_R14S[1:0], //Sample Location to Be Tested
   output logic 			isQuad_R14H, //Micropygon is quad
   output logic 			validSamp_R14H,                   //Sample and Micropolygon are Valid

   /* Indicates whether the current sample was a hit, from sample test. */
   input logic hit
   );
   
   
   // This module implement a Moore machine to iterarte sample points in bbox
   // Recall: a Moore machine is an FSM whose output values are determined 
   // solely by its current state.
   // A simple way to build a Moore machine is to make states for every output
   // and the values of the current states are the outputs themselves
   
   // Now we create the signals for the next states of each outputs and 
   // then instantiate registers for storing these states
   logic signed [`$sig_fig`-1:0] 	next_poly_R14S[`$verts`-1:0][`$axis`-1:0]; 
   logic unsigned  [`$sig_fig`-1:0] next_color_R14U[`$colors`-1:0] ;
   logic signed [`$sig_fig`-1:0] 	next_sample[1:0];  
   logic 				next_isQuad_R14H;                   
   logic 				next_validSamp_R14H;                 
   logic 				next_halt_RnnnnL;
   
   
   // Instantiate registers for storing these states
   //; my $d301 = generate( 'dff3', "d301", 
   //;                        BitWidth=>$sig_fig,
   //;                        ArraySize1=>$verts,
   //;                        ArraySize2=>$axis,
   //;                        PipelineDepth=>1,
   //;                        Retime=>'NO' );
   `$d301->instantiate()`(
			  .in(next_poly_R14S) , 
			  .clk(clk) , .reset(rst), .en(1'b1),
			  .out(poly_R14S));
   
   //; my $d302 = generate( 'dff2', "d302", 
   //;                        BitWidth=>$sig_fig,
   //;                        ArraySize1=>$colors,
   //;                        PipelineDepth=>1,
   //;                        Retime=>'NO' );
   `$d302->instantiate()` (
			   .in(next_color_R14U) , 
			   .clk(clk) , .reset(rst), .en(1'b1),
			   .out(color_R14U));
   
   //; my $d303 = generate( 'dff2', "d303", 
   //;                        BitWidth=>$sig_fig,
   //;                        ArraySize1=>2,
   //;                        PipelineDepth=>1,
   //;                        Retime=>'NO' );
   `$d303->instantiate()` (
			   .in(next_sample) , 
			   .clk(clk) , .reset(rst), .en(1'b1),
			   .out(sample_R14S));				 
   
   //; my $d304 = generate( 'dff', "d304", 
   //;                        BitWidth=>3,
   //;                        PipelineDepth=>1,
   //;                        Retime=>'NO' );
   `$d304->instantiate()` (
			   .in({next_validSamp_R14H, next_isQuad_R14H, next_halt_RnnnnL}) , 
			   .clk(clk) , .reset(rst), .en(1'b1),
			   .out({validSamp_R14H, isQuad_R14H, halt_RnnnnL}));
   // Instantiate registers for storing these states
   

   
   //; if ($mod_FSM eq 'NO') {

   logic signed [`$sig_fig`-1:0] 	box_R14S[1:0][1:0], next_box_R14S[1:0][1:0];

   enum {
      TEST = 0,
      DIRECTION = 1, 
      SEEK = 2 
   } state_index_t;

   /* We want the initial state to be the WAIT state, so set it 0. */
   enum {
      WAIT_STATE = 1'b0,
      TEST_STATE = 1'b1
   } state_w;
   enum {
      RIGHT_STATE = 1'b0,
      LEFT_STATE = 1'b1
   } state_d;
   enum {
      SEEK_STATE = 1'b0,
      CHECK_STATE = 1'b1 
   } state_i;



   logic [2:0] state_14, next_state_14; 
   
   // instantiate registers for storing these two states
   //; my $d305 = generate( 'dff3', "d305", 
   //;                        BitWidth=>$sig_fig,
   //;                        ArraySize1=>2,
   //;                        ArraySize2=>2,
   //;                        PipelineDepth=>1,
   //;                        Retime=>'NO' );
   `$d305->instantiate()` (
			   .in(next_box_R14S) , 
			   .clk(clk) , .reset(rst), .en(1'b1),
			   .out(box_R14S));
   
   
   //; my $d306 = generate( 'dff', "d306", 
   //;                        BitWidth=>3,
   //;                        PipelineDepth=>1,
   //;                        Retime=>'NO' );
   `$d306->instantiate()` (
			   .in(next_state_14) , 
			   .clk(clk) , .reset(rst), .en(1'b1),
			   .out(state_14));

   /* When finished: */
   /* IMPORTANT: INSTANTIATE FLOPS TO STORE INTERMEDIATE SIGNAL */
   /* IMPORTANT: INSTANTIATE FLOPS TO STORE INTERMEDIATE SIGNAL */
   /* IMPORTANT: INSTANTIATE FLOPS TO STORE INTERMEDIATE SIGNAL */
   /* IMPORTANT: INSTANTIATE FLOPS TO STORE INTERMEDIATE SIGNAL */
   /* IMPORTANT: INSTANTIATE FLOPS TO STORE INTERMEDIATE SIGNAL */
   /* IMPORTANT: INSTANTIATE FLOPS TO STORE INTERMEDIATE SIGNAL */
   /* IMPORTANT: INSTANTIATE FLOPS TO STORE INTERMEDIATE SIGNAL */
   /* IMPORTANT: INSTANTIATE FLOPS TO STORE INTERMEDIATE SIGNAL */
   /* IMPORTANT: INSTANTIATE FLOPS TO STORE INTERMEDIATE SIGNAL */
   

   /* Helper Signals */
   /* ------------------------------------- */   
   logic signed [`$radix`:0] inc; //increment

   logic signed [`$sig_fig`-1:0] iter_sample[1:0], up_sample[1:0], other_sample[1:0]; 
   logic at_right, at_left, at_top, line_finished;      
   logic finished;      


   /* Wait-dependent signals */
   /* ------------------------------------- */   
   always_comb begin
      unique if (!state_14[TEST] /*|| (state_14[TEST] && finished)*/) begin
         next_state_14[TEST]   = validPoly_R13H;

         next_sample           = box_R13S[0]; 

         next_validSamp_R14H   = validPoly_R13H;
         next_isQuad_R14H      = isQuad_R13H;
         next_poly_R14S        = poly_R13S;
         next_color_R14U       = color_R13U;
         next_box_R14S         = box_R13S;
      end else begin
         next_state_14[TEST]   = !finished; 

         next_sample           = iter_sample;

         next_validSamp_R14H   = !finished;
         next_isQuad_R14H      = isQuad_R14H;
         next_poly_R14S        = poly_R14S; 
         next_color_R14U       = color_R14U; 
         next_box_R14S         = box_R14S; 
      end

      next_halt_RnnnnL = !next_state_14[TEST];
   end

   /* Direction-dependent signals */
   /* ------------------------------------- */   
   always_comb begin
      at_top = (sample_R14S[1] >= box_R14S[1][1]);
      at_right =  (sample_R14S[0] >= box_R14S[1][0]);
      at_left =  (sample_R14S[0] <= box_R14S[0][0]);

      line_finished = at_right;
      finished = line_finished && at_top;

      next_state_14[DIRECTION] = RIGHT_STATE;
      inc[`$radix`-1:0] = (subSample_RnnnnU<<(`$radix`-3));
      inc[`$radix`] = state_14[DIRECTION];

      {up_sample[0], up_sample[1]} = {box_R14S[0][0], sample_R14S[1]+inc[`$radix`-1:0]};

      {next_iter_sample[0], next_iter_sample[1]} = {sample_R14S[0]+inc, sample_R14S[1]};



      iter_sample = (line_finished) ? up_sample 
         : (!switch) ? next_iter_sample
         : other_sample;

      next_other_sample = (!switch) ? other_sample
         : sample_R14S;

   end

   /* ------------------------------------- */   

   /* Hit-dependent signals */
   /* ------------------------------------- */   
   /* Stay in the SEEK state until we hit. 
      Stay in the CHECK state until we either finish a line, or miss. */

   always_comb begin
      unique if (state_14(SEEK)) begin
         next_state_14[SEEK] = hit;
      end else begin
         next_state_14[SEEK] = !(line_finished || !hit);
      end
   end
   
   /* ------------------------------------- */   

   

   
   



   //Error Checking Assertions
   /* -------------------------- */

   //Define a Less Than Property
   //  a should be less than b
   property rb_lt( rst, a , b , c );
      @(posedge clk) rst | ((a<=b) | !c);
   endproperty

   //Check that Proposed Sample is in BBox
   assert property( rb_lt( rst, next_sample[0] , next_box_R14S[1][0] , next_validSamp_R14H ));
   assert property( rb_lt( rst, next_sample[1] , next_box_R14S[1][1] , next_validSamp_R14H ));
   assert property( rb_lt( rst, next_box_R14S[0][0] , next_sample[0] , next_validSamp_R14H ));
   assert property( rb_lt( rst, next_box_R14S[0][1] , next_sample[1] , next_validSamp_R14H ));
   /* -------------------------- */




   
   //; } else { # use Modified FSM
   

   
   //; }


endmodule
